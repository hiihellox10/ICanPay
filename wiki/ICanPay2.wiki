#labels 实现基类支持其他网关
= 实现基类支持其他网关 =

这里将会讲述ICanPay的原理，你可以通过扩展基类来支持更多的网关。


  * [http://code.google.com/p/icanpay/wiki/ICanPay2#从最简单的开始 从最简单的开始]
    * [http://code.google.com/p/icanpay/wiki/ICanPay2#新建一个通过Form提交订单的新网关 新建一个通过Form提交订单的新网关]
    * [http://code.google.com/p/icanpay/wiki/ICanPay2#查询、生成订单使用的其他接口 查询、生成订单使用的其他接口]
  * [http://code.google.com/p/icanpay/wiki/ICanPay2#接收网关服务器的通知 接收网关服务器的通知]
    * [http://code.google.com/p/icanpay/wiki/ICanPay2#识别网关类型 识别网关类型]
    * [http://code.google.com/p/icanpay/wiki/ICanPay2#实现网关通知的检查 实现网关通知的检查]
    * [http://code.google.com/p/icanpay/wiki/ICanPay2#输出接收到正确网关通知的标记字符串 输出接收到正确网关通知的标记字符串]

  * [http://code.google.com/p/icanpay/wiki/ICanPay2#主要接口介绍 主要接口介绍]

----

== 从最简单的开始 ==
 ==== 新建一个通过Form提交订单的新网关 ====

我们将新的需要实现的网关命名为DemoPay，首先要做的就是在GatewayType枚举中增加DemoPay枚举成员
{{{
namespace ICanPay
{
    public enum GatewayType
    {
        // ...省略已有代码
        DemoPay = 5
    }
}
}}}

然后我们要做的事情就是让他尽快可以用来生成一个Form提交的订单。建立一个新的网关首先要实现PayGateway的GatewayName属性跟CheckNotifyData方法。
{{{
namespace ICanPay.Providers
{
    public class DemoPayGateway : PayGateway, IPaymentForm
    {
        const string payGatewayUrl = @"https://pay.DemoPay.com/PayGate";
        Dictionary<string, string> parma;

        public override GatewayType GatewayName
        {
            get
            {
                return GatewayType.DemoPay ;
            }
        }

        protected override bool CheckNotifyData()
        {
            // 暂时未实现通知的处理
            return false;
        }

        public string BuildPaymentForm()
        {
            parma = new Dictionary<string, string>();
            parma.Add("mid", Merchant.UserName);
            parma.Add("oid", Order.OrderId);
            parma.Add("amount", Order.Amount.ToString());
            parma.Add("moneytype", "CNY");
            parma.Add("url", Merchant.NotifyUrl);

            return GetForm(parma, payGatewayUrl);
        }
    }
}
}}}

在这里我们需要提交到的Url是https://pay.DemoPay.com/PayGate， 因为不同的网关可能只能使用POST或者GET方式的一种来提交订单，所以根据网关支持的提交方式来选择继承并实现IPaymentForm接口或者IPaymentUrl接口。

上面的例子我们是实现了IPaymentForm接口。在BuildPaymentForm方法中，你需要参考相应网关的开发文档添加订单所需要的参数跟值。

在BuildPaymentForm方法中我们添加了订单中所需要的参数跟值，最后使用GetForm方法产生如下的HTML Form代码
{{{
<form name='Gateway' method='post' action =https://pay.DemoPay.com/PayGate>
<input type='hidden' name='mid' value='10000432521'>
<input type='hidden' name='oid' value='1564515'>
<input type='hidden' name='amount' value='0.01'>
<input type='hidden' name='moneytype' value='CNY'>
<input type='hidden' name='url' value='http://yousite.com/Notify.aspx'>
</form>
<script type='text/javascript'>window.document.Gateway.submit();</script>
}}}


----
  ==== 查询、生成订单使用的其他接口 ====

用于建立订单的接口是IPaymentForm、IPaymentUrl。

用于建立查询订单的接口是IQueryForm、IQueryUrl。

IQueryForm、IQueryUrl接口实现的查询跟IPaymentForm、IPaymentUrl接口的实现类似，都是向服务器提交数据然后网关服务器返回查询的结果。在已有的4个支付网关的实现中CheckNotifyData方法可以处理订单支付结果的通知跟订单查询结果的通知。

因为有的网关是通过POST查询数据给网关，网关返回的HTTP流中将包含订单的数据，而不是网关给指定的Url返回数据。

ICheckPayment接口用于处理这种类型的实现，相当于PayGateway的CheckNotifyData方法。

例如YeepayGateway就是使用ICheckPayment来查询订单的状态，而不是实现IQueryForm、IQueryUrl接口。它的使用如下：
{{{
PaymentSetting<YeepayGateway> ps = new PaymentSetting<YeepayGateway>();
ps.PayGateway.Merchant.UserName = "10000432521";
ps.PayGateway.Merchant.Key = "8UPp0KE8sq73zVP370vko7C39403rtK1YwX40Td6irH216036H27Eb12792t";
ps.PayGateway.Order.OrderId = "1564515";
ps.PayGateway.Order.Amount = 0.01;

if(ps.PayGateway.CheckPayment())
{
    // 订单已支付
}
}}}

----

  == 接收网关服务器的通知 ==
   ==== 识别网关类型 ====

要让DemoPay可以用于处理网关的通知，首先要能够识别是哪一个网关以便创建相应的实现。

网关通知的识别，并建立相应的网关是由ProcessNotify类的GetGateway方法来完成的。在ICanPay中通过对网关通知数据参数的检查来识别是哪一个网关。

{{{
        public PayGateway GetGateway()
        {
            if (IsDemoPayGateway)
            {
                return new DemoPayGateway();
            }
            return null;
        }

        private bool IsDemoPayGateway
        {
            get
            {
                  string[] verifyKeys = { "r0_Cmd", "r1_Code", "r2_TrxId", "r3_Amt" };
                  return PayUtility.ContainsKey(verifyKeys, notifyData);
            }
        }
}}}

你可以将通知中需要包含的参数添加到verifyKeys数组中，尽量多添加通知中必须包含的参数已跟其他网关区别，以便不被识别为其他网关。

PayUtility.ContainsKey(verifyKeys, notifyData)方法将检查verifyKeys中的参数是否在接收到的通知notifyData中。notifyData保存的是网关通过GET或者POST发送过来的参数。

----

   ==== 实现网关通知的检查 ====

在完成上面的步骤后，已经可以正确的识别网关的通知了，余下的就是检查网关的通知是否正确。

PayGateway的CheckNotifyData方法用于检查网关通知的正确性。

{{{
        protected override bool CheckNotifyData()
        {
            // 通知数据中必须包含的Key，如果没有表示数据可能非法
            string[] checkParma = { "cmdno", "pay_result", "pay_info", "date", "transaction_id", 
                                 "sp_billno", "total_fee", "fee_type", "attach" };

            if (!PayUtility.ContainsKey(checkParma, OtherData))
            {
                return false;
            }

            // 检查订单是否支付成功，订单签名是否正确，货币类型是否为RMB
            if (OtherData["sign"] == NotifySign() && OtherData["fee_type"] == "1" &&
                  OtherData["pay_result"] == "0" && OtherData["pay_info"] == "OK")
            {
                Order.Amount = Convert.ToDouble(OtherData["total_fee"]) * 0.01;
                Order.OrderId = OtherData["sp_billno"];

                return true;
            }

            return false;
        }
}}}

网关通过GET或者POST发送过来的通知都是保存在OtherData中。首先要做的是验证将要使用到的数据跟一些必须的数据数否在OtherData中，在checkParma数组中设置了通知中必须包含的参数。如果缺少参数则返回false。

*接下来的步骤将是判断签名、货币类型、支付成功标识是否都正确，这里是最重要的用来判断网关通知是否合法的代码。*对于这部分你需要阅读相应网关的开发文档来完成，没有问题的话则将网关通知中的订单金额跟订单编号赋值给Order，在处理订单的逻辑代码中将通过检查订单编号跟金额跟数据库中是否符合已做下一步处理。


----

   ==== 输出接收到正确网关通知的标记字符串 ====

因为ICanPay在接收到网关正确通知后，会根据网关的要求输出标记成功接收到网关通知的字符串。网关在接收到标记成功接收到通知的字符串后将不再发送通知，或者根据输出字符串的内容将付款用户跳转到相应网页。

如果你实现的这个网关需要输出标记成功接收到网关通知的字符串你可以通过覆盖WriteSucceedFlag方法来实现。

例如：
{{{
        protected override void WriteSucceedFlag()
        {
            System.Web.HttpContext.Current.Response.Write("success");
        }
}}}


----

== 主要接口介绍 ==
因为网关之间的差异，造成了生成订单、查询订单的接口不统一。所以根据需要来选择继承相应的接口，下面将会做具体说明。


 === 选择需要实现的接口 ===


因为网关间的差异，有的使用Form提交、查询订单或者使用Url提交、查询订单，而有的网关是通过向网关服务器发送查询订单数据后，网关服务器通过输出HTTP流的方式来返回订单查询结果。在这里ICanPay提供了5个接口，根据需要实现需要的接口就可以了。

 * IPaymentUrl 创建支付订单的Url
 * IQueryUrl 创建查询订单的Url
 * IPaymentForm 创建支付订单的Form
 * IQueryForm 创建查询订单的Form
 * ICheckPayment 通过读取网关服务器输出HTTP流的方式查询订单结果


例如：
中国网银Chinabank的网关只支持通过Form来提交、查询订单，而不能通过Url来提交、查询订单。所以他只需要要实现IPaymentForm、IQueryForm接口，而不需要实现另外的IQueryUrl、IPaymentUrl接口。而财付通Tenpay则正好相反。

如果有的网关没有提供查询，则不用实现IQueryForm、IQueryUrl或者ICheckPayment。

如果网关提供的是输出HTTP流的方式来返回订单查询结果，那么你需要实现ICheckPayment接口。